\section{Architecture}
A client-server model with a REST API was chosen as the tool architecture. The
proposed solution allows the tool to be used by multiple users simultaneously,
as well as enabling deployment to distributed systems with distinct roles,
responsibilities, and hardware resources.
The frontend is a simple thin client whose sole job is relaying commands to a
server and showing the returned results. The server is tasked with obtaining
and processing the available YouTube data, and otherwise interacting with the
API.
Local deployment is a viable option, given sufficient storage and networking
capabilities.


\subsection{Client}
The user interface of the tool is written in AngularJS, an open-source framework
that facilitates easy setup and management of single-page web applications using
the model-view-controller (MVC) pattern.~\cite{architecture:angularjs}

The frontend is separated into four main pages that each have a specific
function: Management of API keys, creation of API queries, creation of celery
tasks, and results presentation.


\subsubsection{User management}


\subsubsection{API key management}
The API key management page lets the user register API keys to his account.
API keys are instantly validated and, if valid, added to the dropdown list of
available keys on the query builder page.
While only a single key is required per API request (in the absence of OAuth
2.0), having access to multiple keys makes for quick and easy testing and the
ability to generate keys for a specific purpose or dataset. The latter is
shown in action on the Result page, where the user can view statistics filtered
by a given API key. %TODO: refine?


\subsubsection{Query Builder}
On the Query builder page the user may build individual search queries using
the provided interface. YouTube's API defines a set of options which we present
to the user in the form of input boxes. Our algorithm for assuring unique
results requires a timeframe, thus the two relevant query fields are required - 
all other fields are deemed optional. Query fields that specify operations
specifically on the user's own videos are deliberately omitted as this is
not within the scope of the tool.

Before queries are dispatched to the task workers and any real work is
performed, they are validated by issuing a small version of the query for
verification only. The user is immediately notified if any of the given query
parameters create an invalid combination. This will prove invaluable to new
users who can safely learn to use the YouTube API, as well as preventing
the storage of invalid queries.
%TODO: reword?


\subsubsection{Task Page}
Stored queries may be executed on the Task page. The user selects the task he
wants performed and a query which defines the set of videos on which to operate.
The first operation will always be the fetching of video IDs, as the rest of the
available tasks depend on this. Multiple tasks may be launched in parallell.
Progress bars are updated in real-time. %TODO: too short and list-y. Reword?


\subsubsection{Result page}
The Result page contains selected statistics for the dataset returned by a given
query. Of particular note is the graph showing the intersection between datasets. This
allows the user to quickly identify closely related queries, and can be helpful
in e.g. parameter studies.
%TODO: Maybe refine a bit.


\subsection{Server}
The server is written in python %TODO: finish


\subsubsection{Background tasks}
All requests created by the frontend are handled asynchronously by Celery and
Redis.

Celery is used as an asynchronous task queue based on distributed messages. It
is capable of distributing tasks over a potentially vast network of nodes.
~\cite{architecture:celery} Redis is a networked in-memory key-value database.
~\cite{architecture:redis} The frameworks aren't used to their full extent given
our current single-server environment, but having these frameworks already
present will be of great aid in future expansion.

After a task has been scheduled by the user, it is immediately pushed to Redis
and put in a pending state until a Celery worker is available to process it.
While the task is executing, Celery provides an interface with which to control
it. It is because of this feature an in-memory database to keep track of running
tasks is preferential. Given that our fetcher modules, the actual tasks that are
being run, update their own status in the database after every single request to
the YouTube API, a disk I/O-bound database would potentially severely limit
performance.

