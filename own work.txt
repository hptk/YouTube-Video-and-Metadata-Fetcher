Architecture

As an architecture for our tool we chose a client-server model with a REST API. The proposed solution does not only allow
multiple users and collaboration but also to distribute the server on a 


The Frontend

The tool's frontend is written in AngularJS, which is an open-source framework from Google. 
It allows to create single page javascript web applications by providing a client-server model-view-controller (MVC) pattern.
In our implementation, each page has it's own small MVC pattern for better structure and maint

The services are binded to our REST API

The Server Backend

The Background Tasks

Since we already have a centralized server which processes all tasks created by the clients, such as searching for 
video IDs and extracting the metadata, we had to think about how to run these tasks in a non-blocking way.
This is important
because the users might want to create multiple tasks at once and the frontend should not be blocked until one long running task
is finished. In order to solve this problem, we had to utilize a task queue system and selected a message broker to feed the task queue.
We selected Celery as our task queue and Redis as a message broker.
Celery is an asynchronous task queue based on distributed messages 
Redis itself is an open-source, networked, in-memory key-value data structure server. For our
purpose we do not utilize the full capabilities of Celery and Redis, since we have one centralized server, but using
this architecture from the very beginning makes it easy to distribute our tool on multiple servers which process the individual tasks and only
have some light weight clients which request our API.
This might be important for performance improvements and further developments.