#!/usr/bin/python

import Queue
import threading
import time
import urllib2, urllib, ssl
import json
import datetime
from elasticsearch import Elasticsearch


exitFlag = 0

DEVELOPER_KEY = "AIzaSyBlO0GfmL5LuRJoVlRhMVM8VjViE5BAAs8"
numberThreads = 100
es_index = "youtubetestindex13"


threadList = []
videoIdList = []


es = Elasticsearch()

class myThread (threading.Thread):
    def __init__(self, threadID, name, q):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.q = q

    def run(self):
        makeRequest(self.name, self.q)

def buildRequest(videoID):
    return "https://www.googleapis.com/youtube/v3/videos?part=contentDetails,status,recordingDetails,topicDetails,statistics,snippet&id="+videoID+"&fields=items(ageGating,contentDetails,conversionPings,etag,fileDetails,kind,liveStreamingDetails,localizations,monetizationDetails,player,processingDetails,projectDetails,recordingDetails,snippet,statistics,status,suggestions,topicDetails)&key="+DEVELOPER_KEY
 

def req(videoID):
        global es
	request = buildRequest(videoID)
	try: 
		result = urllib2.urlopen(request,timeout=2)
	except urllib2.URLError as e:
		if hasattr(e,"reason"):
			print e.reason
			doc = {
				"reason": e.reason,
				"request": request,
			}
		elif hasattr(e,"code"):
			print e.code
			doc = {
				"error_code": e.code,
				"request": request,
			}
		es.index(index=es_index,doc_type="URLError",body=doc)
	except urllib2.HTTPError as e:
		doc = {
			"error_code": e.code,
			"request": request,
		}
		es.index(index="youtubetestindexerror",doc_type="HTTPError",body=doc)
	except ssl.SSLError as e:
		print request
    
	else: 
		jsonResult = json.loads(result.read())
		if "items" in jsonResult:
			for item in jsonResult['items']:
                                doc = {"doc": {
				    "duration": item["contentDetails"]["duration"],
				    "dimension": item["contentDetails"]["dimension"],
                                    "definition": item["contentDetails"]["definition"],
                                    "caption": item["contentDetails"]["caption"],
                                    "licensedContent": item["contentDetails"]["licensedContent"],
                                    "uploadStatus": item["status"]["uploadStatus"],
                                    "privacyStatus": item["status"]["privacyStatus"],
                                    "license": item["status"]["license"],
                                    "embeddable": item["status"]["embeddable"],
                                    "publicStatsViewable": item["status"]["publicStatsViewable"],
                                    "viewCount": item["statistics"]["viewCount"],
                                    "likeCount": item["statistics"]["likeCount"],
                                    "dislikeCount": item["statistics"]["dislikeCount"],
                                    "favoriteCount": item["statistics"]["favoriteCount"],
                                    "commentCount": item["statistics"]["commentCount"],

			        }}
                                #delete "id" in response, otherwise conflict with Elasticsearch id
                                
                                doc2 = {"doc":item}
				es.update(index=es_index,doc_type="video",id=videoID,body=doc2)
                                
                                
			

def makeRequest(threadName, q):
    while not exitFlag or not workQueue.empty():
        queueLock.acquire()
        if not workQueue.empty():
            videoID = q.get()
            queueLock.release()
           
            req(videoID)
            
        else:
            queueLock.release()

for x in xrange(0,numberThreads):
    threadList.append(x)

response = es.search(index=es_index,doc_type="video",size=1000*numberThreads,q="_missing_:fetchedMeta",fields="_id")

queueLock = threading.Lock()
workQueue = Queue.Queue(0)
threads = []
threadID = 0

# Create new threads
for tName in threadList:
    thread = myThread(threadID, tName, workQueue)
    thread.start()
    threads.append(thread)
    threadID += 1

# Fill the queue
queueLock.acquire()
for hit in response["hits"]["hits"]:
    workQueue.put(hit["_id"])

starttime = datetime.datetime.now()
queueLock.release()

# Notify threads it's time to exit
exitFlag = 1

# Wait for all threads to complete
for t in threads:
    t.join()


#print str(totalFrame)+"\t"+str(secondsPerFrame)+"\t"+str(countAll)+"\t"+str(len(videoIDs))+"\t"+str(pageAll)+"\t"+str(countRequests)+"\t"+str((datetime.datetime.now()-starttime).total_seconds())

